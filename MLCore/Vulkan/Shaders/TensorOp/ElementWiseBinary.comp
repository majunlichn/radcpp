#version 460 core

#extension GL_GOOGLE_include_directive : require

#include "Common/DataType.h"

layout(push_constant, std430) uniform PushConstants
{
    uint g_inputIndexOffset;
    uint g_otherIndexOffset;
    uint g_outputIndexOffset;
};

#if ((DATA_TYPE_ID == DataTypeFloat16) || (DATA_TYPE_ID == DataTypeFloat32))
    struct Params { float32_t s0; float32_t s1; float32_t s2; float32_t s3; };
#elif (DATA_TYPE_ID == DataTypeFloat64)
    struct Params { float64_t s0; float64_t s1; float64_t s2; float64_t s3; };
#elif ((DATA_TYPE_ID == DataTypeSint8) || (DATA_TYPE_ID == DataTypeSint16) || (DATA_TYPE_ID == DataTypeSint32))
    struct Params { int32_t s0; int32_t s1; int32_t s2; int32_t s3; };
#elif (DATA_TYPE_ID == DataTypeSint64)
    struct Params { int64_t s0; int64_t s1; int64_t s2; int64_t s3; };
#elif ((DATA_TYPE_ID == DataTypeUint8) || (DATA_TYPE_ID == DataTypeUint16) || (DATA_TYPE_ID == DataTypeUint32))
    struct Params { uint32_t s0; uint32_t s1; uint32_t s2; uint32_t s3; };
#elif (DATA_TYPE_ID == DataTypeUint64)
    struct Params { uint64_t s0; uint64_t s1; uint64_t s2; uint64_t s3; };
#elif (DATA_TYPE_ID == DataTypeBool)
    struct Params { uint32_t s0; uint32_t s1; uint32_t s2; uint32_t s3; };
#elif DATA_TYPE_IS_COMPLEX
    struct Params { COMPLEX s0; COMPLEX s1; COMPLEX s2; COMPLEX s3; };
#endif

layout(set = 0, binding = 0) uniform Uniforms
{
    uvec4 g_sizes;
    uvec4 g_inputStrides;
    uvec4 g_otherStrides;
    uvec4 g_outputStrides;
    Params g_params;
};

layout(set = 0, binding = 1) readonly buffer InputTensor { DATA_TYPE g_inputTensor[]; };
layout(set = 0, binding = 2) readonly buffer OtherTensor { DATA_TYPE g_otherTensor[]; };
layout(set = 0, binding = 3) buffer OutputTensor { DATA_TYPE g_outputTensor[]; };

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

#if defined(Add)
#if DATA_TYPE_IS_COMPLEX
COMPLEX Multiply(const COMPLEX a, const COMPLEX b)
{
    return COMPLEX(a.real * b.real - a.imag * b.imag, a.real * b.imag + a.imag * b.real);
}
COMPLEX Add(const COMPLEX a, COMPLEX b)
{
    b = Multiply(g_params.s0, b);
    return COMPLEX(a.real + b.real, a.imag + b.imag);
}
#else
COMPUTE_TYPE Add(const COMPUTE_TYPE a, const COMPUTE_TYPE b)
{
    return a + COMPUTE_TYPE(g_params.s0) * b;
}
#endif
#endif

#if defined(Subtract)
#if DATA_TYPE_IS_COMPLEX
COMPLEX Multiply(const COMPLEX a, const COMPLEX b)
{
    return COMPLEX(a.real * b.real - a.imag * b.imag, a.real * b.imag + a.imag * b.real);
}
COMPLEX Subtract(const COMPLEX a, COMPLEX b)
{
    b = Multiply(g_params.s0, b);
    return COMPLEX(a.real - b.real, a.imag - b.imag);
}
#else
COMPUTE_TYPE Subtract(const COMPUTE_TYPE a, const COMPUTE_TYPE b)
{
    return a - COMPUTE_TYPE(g_params.s0) * b;
}
#endif
#endif

#if defined(Multiply)
#if DATA_TYPE_IS_COMPLEX
COMPLEX Multiply(const COMPLEX a, const COMPLEX b)
{
    return COMPLEX(a.real * b.real - a.imag * b.imag, a.real * b.imag + a.imag * b.real);
}
#else
COMPUTE_TYPE Multiply(const COMPUTE_TYPE a, const COMPUTE_TYPE b)
{
    return a * b;
}
#endif
#endif

#if defined(Divide)
#if DATA_TYPE_IS_COMPLEX
COMPLEX Divide(const COMPLEX a, const COMPLEX b)
{
    COMPLEX_COMPONENT_TYPE denom = b.real * b.real + b.imag * b.imag;
    return COMPLEX((a.real * b.real + a.imag * b.imag) / denom, (a.imag * b.real - a.real * b.imag) / denom);
}
#else
COMPUTE_TYPE Divide(const COMPUTE_TYPE a, const COMPUTE_TYPE b)
{
    return a / b;
}
#endif
#endif

#if defined(Remainder)
COMPUTE_TYPE Remainder(const COMPUTE_TYPE a, const COMPUTE_TYPE b)
{
#if DATA_TYPE_IS_FLOATING_POINT
    return mod(a, b);
#elif DATA_TYPE_IS_SIGNED_INTEGRAL
    COMPUTE_TYPE r = a - a / b * b;
    if ((r != 0) && ((a < 0) != (b < 0)))
    {
        r += b;
    }
    return r;
#elif DATA_TYPE_IS_UNSIGNED_INTEGRAL
    return a % b;
#endif
}
#endif

#if defined(BitwiseAnd)
COMPUTE_TYPE BitwiseAnd(const COMPUTE_TYPE a, const COMPUTE_TYPE b)
{
    return a & b;
}
#endif

#if defined(BitwiseOr)
COMPUTE_TYPE BitwiseOr(const COMPUTE_TYPE a, const COMPUTE_TYPE b)
{
    return a | b;
}
#endif

#if defined(BitwiseXor)
COMPUTE_TYPE BitwiseXor(const COMPUTE_TYPE a, const COMPUTE_TYPE b)
{
    return a ^ b;
}
#endif

void main()
{
    const uint SizeN = g_sizes[0];
    const uint SizeC = g_sizes[1];
    const uint SizeH = g_sizes[2];
    const uint SizeW = g_sizes[3];
    const uint n = gl_GlobalInvocationID.z;
    const uint h = gl_GlobalInvocationID.y;
    const uint w = gl_GlobalInvocationID.x;
    if ((w >= SizeW) || (h >= SizeH))
    {
        return;
    }
    for (uint c = 0; c < SizeC; ++c)
    {
        uint inputIndex = g_inputIndexOffset + n * g_inputStrides[0] + c * g_inputStrides[1] +
                            h * g_inputStrides[2] + w * g_inputStrides[3];
        uint otherIndex = g_otherIndexOffset + n * g_otherStrides[0] + c * g_otherStrides[1] +
                            h * g_otherStrides[2] + w * g_otherStrides[3];
        uint outputIndex = g_outputIndexOffset + n * g_outputStrides[0] + c * g_outputStrides[1] +
                            h * g_outputStrides[2] + w * g_outputStrides[3];
#if DATA_TYPE_IS_COMPLEX
        const COMPLEX a = g_inputTensor[inputIndex];
        const COMPLEX b = g_otherTensor[otherIndex];
        g_outputTensor[outputIndex] = ELEMENT_OP(a, b);
#else
        const COMPUTE_TYPE a = COMPUTE_TYPE(g_inputTensor[inputIndex]);
        const COMPUTE_TYPE b = COMPUTE_TYPE(g_otherTensor[otherIndex]);
        g_outputTensor[outputIndex] = DATA_TYPE(ELEMENT_OP(a, b));
#endif
    }
}
