#version 450 core

#extension GL_GOOGLE_include_directive : require

#include "Common/DataType.h"

layout(push_constant, std430) uniform PushConstants
{
    uint g_inputIndexOffset;
    uint g_outputIndexOffset;
};

#ifndef PARAM_TYPE
    #if DATA_TYPE_IS_FLOATING_POINT
        #if ELEMENT_SIZE <= 4
            #define PARAM_TYPE f32vec4
        #elif DATA_TYPE_ID == DataTypeFloat64
            #define PARAM_TYPE f64vec4
        #endif
    #elif DATA_TYPE_IS_SIGNED_INTEGRAL
        #if ELEMENT_SIZE <= 4
            #define PARAM_TYPE i32vec4
        #else
            #define PARAM_TYPE i64vec4
        #endif
    #elif DATA_TYPE_IS_UNSIGNED_INTEGRAL
        #if ELEMENT_SIZE <= 4
            #define PARAM_TYPE u32vec4
        #else
            #define PARAM_TYPE u64vec4
        #endif
    #elif DATA_TYPE_IS_BOOL
        #define PARAM_TYPE u32vec4
    #elif DATA_TYPE_IS_COMPLEX
        struct Params { DATA_TYPE x; DATA_TYPE y; DATA_TYPE z; DATA_TYPE w; };
        #define PARAM_TYPE Params
    #endif // DATA_TYPE_IS_*
#endif // PARAM_TYPE

layout(set = 0, binding = 0) uniform Uniforms
{
    uvec4 g_sizes;
    uvec4 g_inputStrides;
    uvec4 g_outputStrides;
    uvec4 g_padding; // Unused, just for alignment
    PARAM_TYPE g_params;
};

layout(set = 0, binding = 1) readonly buffer InputTensor { DATA_TYPE g_inputTensor[]; };
layout(set = 0, binding = 2) buffer OutputTensor { DATA_TYPE g_outputTensor[]; };

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

#if defined(AddScalar)
#if DATA_TYPE_IS_COMPLEX
COMPLEX AddScalar(in COMPLEX x)
{
    const COMPLEX a = x;
    const COMPLEX b = g_params.x;
    return COMPLEX(a.real + b.real, a.imag + b.imag);
}
#else
COMPUTE_TYPE AddScalar(COMPUTE_TYPE x)
{
    return x + COMPUTE_TYPE(g_params.x);
}
#endif
#endif

#if defined(SubtractScalar)
#if DATA_TYPE_IS_COMPLEX
COMPLEX SubtractScalar(in COMPLEX x)
{
    const COMPLEX a = x;
    const COMPLEX b = g_params.x;
    return COMPLEX(a.real - b.real, a.imag - b.imag);
}
#else
COMPUTE_TYPE SubtractScalar(COMPUTE_TYPE x)
{
    return x - COMPUTE_TYPE(g_params.x);
}
#endif
#endif

#if defined(MultiplyScalar)
#if DATA_TYPE_IS_COMPLEX
COMPLEX MultiplyScalar(COMPLEX x)
{
    const COMPLEX a = x;
    const COMPLEX b = g_params.x;
    return COMPLEX(a.real * b.real - a.imag * b.imag, a.real * b.imag + a.imag * b.real);
}
#else
COMPUTE_TYPE MultiplyScalar(COMPUTE_TYPE x)
{
    return x * COMPUTE_TYPE(g_params.x);
}
#endif
#endif

#if defined(DivideScalar)
#if DATA_TYPE_IS_COMPLEX
COMPLEX DivideScalar(COMPLEX x)
{
    const COMPLEX a = x;
    const COMPLEX b = g_params.x;
    COMPONENT_TYPE denom = b.real * b.real + b.imag * b.imag;
    return COMPLEX((a.real * b.real + a.imag * b.imag) / denom, (a.imag * b.real - a.real * b.imag) / denom);
}
#else
COMPUTE_TYPE DivideScalar(COMPUTE_TYPE x)
{
    return x / COMPUTE_TYPE(g_params.x);
}
#endif
#endif

#if defined(RemainderScalar)
COMPUTE_TYPE RemainderScalar(COMPUTE_TYPE x)
{
    const COMPUTE_TYPE a = x;
    const COMPUTE_TYPE b = COMPUTE_TYPE(g_params.x);
#if DATA_TYPE_IS_FLOATING_POINT
    return mod(a, b);
#else
    return COMPUTE_TYPE(int(a) % int(b));
#endif
}
#endif

#if defined(BitwiseAndScalar)
COMPUTE_TYPE BitwiseAndScalar(COMPUTE_TYPE x)
{
    return x & COMPUTE_TYPE(g_params.x);
}
#endif

#if defined(BitwiseOrScalar)
COMPUTE_TYPE BitwiseOrScalar(COMPUTE_TYPE x)
{
    return x | COMPUTE_TYPE(g_params.x);
}
#endif

#if defined(BitwiseXorScalar)
COMPUTE_TYPE BitwiseXorScalar(COMPUTE_TYPE x)
{
    return x ^ COMPUTE_TYPE(g_params.x);
}
#endif

void main()
{
    const uint SizeN = g_sizes[0];
    const uint SizeC = g_sizes[1];
    const uint SizeH = g_sizes[2];
    const uint SizeW = g_sizes[3];
    const uint n = gl_GlobalInvocationID.z;
    const uint h = gl_GlobalInvocationID.y;
    const uint w = gl_GlobalInvocationID.x;
    if ((w >= SizeW) || (h >= SizeH))
    {
        return;
    }
    for (uint c = 0; c < SizeC; ++c)
    {
        uint inputIndex = g_inputIndexOffset + n * g_inputStrides[0] + c * g_inputStrides[1] +
                            h * g_inputStrides[2] + w * g_inputStrides[3];
        uint outputIndex = g_outputIndexOffset + n * g_outputStrides[0] + c * g_outputStrides[1] +
                            h * g_outputStrides[2] + w * g_outputStrides[3];
#if DATA_TYPE_IS_COMPLEX
        const COMPLEX x = g_inputTensor[inputIndex];
        g_outputTensor[outputIndex] = ElementOp(x);
#else
        const COMPUTE_TYPE x = COMPUTE_TYPE(g_inputTensor[inputIndex]);
        g_outputTensor[outputIndex] = DATA_TYPE(ElementOp(x));
#endif
    }
}
